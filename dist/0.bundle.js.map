{"version":3,"sources":["webpack:///./node_modules/intersection-observer-polyfill/index.js","webpack:///./node_modules/intersection-observer-polyfill/src/IntersectionObservation.js","webpack:///./node_modules/intersection-observer-polyfill/src/IntersectionObserver.js","webpack:///./node_modules/intersection-observer-polyfill/src/IntersectionObserverController.js","webpack:///./node_modules/intersection-observer-polyfill/src/IntersectionObserverEntry.js","webpack:///./node_modules/intersection-observer-polyfill/src/_IntersectionObserver.js","webpack:///./node_modules/intersection-observer-polyfill/src/geometry.js","webpack:///./node_modules/intersection-observer-polyfill/src/shims/es6-collections.js","webpack:///./node_modules/intersection-observer-polyfill/src/shims/performance.now.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAsE;;AAEtE;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2BAA2B,iEAA4B;AACvD;;AAEe,mFAAoB,E;;;;;;;;;;;;ACdnC;AAAA;AAAA;AAAA;AAAA;AAA0C;AAC2C;AACjB;;AAEpE,kBAAkB,iEAAe;;AAEjC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,iEAAe;AAC1B;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,8DAAY;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAY;AAC9C;AACA;AACA;AACA,mCAAmC,yDAAO;AAC1C;;AAEA;AACA;AACA,oCAAoC,yDAAO;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,kEAAyB;AACvD;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAG;AACnB;;AAEA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,yBAAyB,8DAAY;AACrC;;AAEA;AACA,6BAA6B,8DAAY;AACzC;;AAEA;AACA;AACA;AACA,8BAA8B,yDAAO,iBAAiB,yDAAO;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvLA;AAAA;AAAA;AAAA;AAAgD;AAC8B;AAClB;;AAE5D;AACA,uBAAuB,uEAA8B;;AAErD;AACA,sBAAsB,8DAAO;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,6DAAqB;;AAElD;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,yBAAyB,2BAA2B;AACpD,yBAAyB;AACzB,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEc,mFAAoB,EAAC;;;;;;;;;;;;;AC5GpC;AAAA;AAAA;AAA0C;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,sEAAG;AAC5C;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,eAAe,OAAO;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,sEAAG;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,sEAAG;AAClB;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7bA;AAAA;AAAA;AAA2C;;AAE5B;AACf;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,UAAU;AACzB;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD,iCAAiC,qBAAqB;AACtD,iCAAiC,OAAO,iEAAe,eAAe;AACtE,iCAAiC,OAAO,iEAAe,aAAa;AACpE,iCAAiC,cAAc;AAC/C,iCAAiC;AACjC,SAAS;AACT;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACJ;AACwB;;AAEhE;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,aAAa;AACxB,aAAa,WAAW;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,eAAe,OAAO,cAAc;AACpC,eAAe,+BAA+B;AAC9C,eAAe,qBAAqB;AACpC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,0DAAG;;AAE/B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,gEAAuB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,8DAAY;;AAEnC;AACA;AACA;;;;;;;;;;;;;ACpVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACO;AACP;;AAEA;AACA,4BAA4B;AAC5B;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,EAAE;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACjJD;AAAA;AACA;AACA;AACA;AACA,aAAa;AACb;AACe;AACf;AACA;AACA;;AAEA;AACA,CAAC,GAAG,E","file":"0.bundle.js","sourcesContent":["import IntersectionObserverPolyfill from './src/IntersectionObserver';\r\n\r\nlet IntersectionObserver;\r\n\r\n// Define what implementation of IntersectionObserver\r\n// needs to be exported: existing or polyfilled.\r\nif (typeof window.IntersectionObserver === 'function') {\r\n    // Export existing IntersectionObservers' implementation.\r\n    IntersectionObserver = window.IntersectionObserver;\r\n} else {\r\n    // Export polyfill.\r\n    IntersectionObserver = IntersectionObserverPolyfill;\r\n}\r\n\r\nexport default IntersectionObserver;","import now from './shims/performance.now';\r\nimport {getArea, getRectangle, createRectangle, isEmpty, isEqual}  from './geometry';\r\nimport IntersectionObserverEntry from './IntersectionObserverEntry';\r\n\r\nconst emptyRect = createRectangle();\r\n\r\n/**\r\n * Tells whether target is a descendant of container element\r\n * and that both of them are present in DOM.\r\n *\r\n * @param {Element} container - Container element.\r\n * @param {Element} target - Target element.\r\n * @returns {Boolean}\r\n */\r\nfunction isDetached(container, target) {\r\n    const docElement = document.documentElement;\r\n\r\n    return (\r\n        container !== docElement && !docElement.contains(container) ||\r\n        !container.contains(target)\r\n    );\r\n}\r\n\r\n/**\r\n * Computes intersection rectangle between two rectangles.\r\n *\r\n * @param {ClientRect} rootRect - Rectangle of container element.\r\n * @param {ClientRect} targetRect - Rectangle of target element.\r\n * @returns {ClientRect} Intersection rectangle.\r\n */\r\nfunction computeIntersection(rootRect, targetRect) {\r\n    const left      = Math.max(targetRect.left, rootRect.left);\r\n    const right     = Math.min(targetRect.right, rootRect.right);\r\n    const top       = Math.max(targetRect.top, rootRect.top);\r\n    const bottom    = Math.min(targetRect.bottom, rootRect.bottom);\r\n\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n\r\n    return createRectangle(left, top, width, height);\r\n}\r\n\r\n/**\r\n * Finds intersection rectangle of provided elements.\r\n *\r\n * @param {Element} container - Container element.\r\n * @param {Element} target - Target element.\r\n * @param {ClientRect} targetRect - Rectangle of target element.\r\n * @param {ClientRect} containterRect - Rectangle of container element.\r\n */\r\nfunction getIntersection(container, target, containterRect, targetRect) {\r\n    let intersecRect    = targetRect,\r\n        parent          = target.parentNode,\r\n        rootReached     = false;\r\n\r\n    while (!rootReached) {\r\n        let parentRect = null;\r\n\r\n        if (parent === container || parent.nodeType !== 1) {\r\n            rootReached = true;\r\n            parentRect = containterRect;\r\n        } else if (window.getComputedStyle(parent).overflow !== 'visible') {\r\n            parentRect = getRectangle(parent);\r\n        }\r\n\r\n        if (parentRect) {\r\n            intersecRect = computeIntersection(intersecRect, parentRect);\r\n        }\r\n\r\n        parent = parent.parentNode;\r\n    }\r\n\r\n    return intersecRect;\r\n}\r\n\r\n/**\r\n * This class is responsible for computing and keeping track of intersections\r\n * between target element and its container. It will create and queue for notification\r\n * new IntersectionObserverEntry when intersection ratio reaches new thresholded value.\r\n */\r\nexport default class IntersectionObservation {\r\n    /**\r\n     * Creates instance of IntersectionObservation.\r\n     *\r\n     * @param {Element} target - Element being observed.\r\n     * @param {IntersectionObserver} observer - Associated IntersectionObserver.\r\n     */\r\n    constructor(target, observer) {\r\n        this.target = target;\r\n        this.observer = observer;\r\n\r\n        this.prevTargetRect = emptyRect;\r\n        this.prevThreshold = 0;\r\n        this.prevRatio = 0;\r\n    }\r\n\r\n    /**\r\n     * Updates intersection data. Creates and queues new\r\n     * IntersectionObserverEntry if intersection threshold has changed.\r\n     *\r\n     * @param {Object} root - Element for which to compute intersection.\r\n     * @param {ClientRect} rootRect - Rectangle of root element.\r\n     * @returns {Object} An object with information about detected changes:\r\n     *  {\r\n     *      ratioChanged: boolean,\r\n     *      targetRectChanged: boolean,\r\n     *      thresholdChanged: boolean\r\n     *  }\r\n     */\r\n    updateIntersection(root, rootRect) {\r\n        let targetRect          = getRectangle(this.target),\r\n            intersection        = this.getIntersectionData(root, rootRect, targetRect),\r\n            threshold           = +intersection.exists,\r\n            ratioChanged        = intersection.ratio !== this.prevRatio,\r\n            targetRectChanged   = !isEqual(targetRect, this.prevTargetRect),\r\n            thresholdChanged;\r\n\r\n        // Find thresholds' index if intersection\r\n        // and target rectangles are not empty.\r\n        if (intersection.exists && !isEmpty(targetRect)) {\r\n            threshold = this.observer.getThresholdGreaterThan(intersection.ratio);\r\n        }\r\n\r\n        thresholdChanged = threshold !== this.prevThreshold;\r\n\r\n        // Update cached properties.\r\n        this.prevTargetRect = targetRect;\r\n        this.prevThreshold = threshold;\r\n        this.prevRatio = intersection.ratio;\r\n\r\n        // Create an empty rectangle if there is no intersection.\r\n        if (!intersection.exists) {\r\n            intersection.ratio = 0;\r\n            intersection.rect = emptyRect;\r\n        }\r\n\r\n        // Create and queue new entry if threshold has changed.\r\n        if (thresholdChanged) {\r\n            const entry = new IntersectionObserverEntry(\r\n                this.target,\r\n                targetRect,\r\n                intersection.rect,\r\n                intersection.ratio,\r\n                rootRect,\r\n                now()\r\n            );\r\n\r\n            this.observer.queueEntry(entry);\r\n        }\r\n\r\n        return {ratioChanged, thresholdChanged, targetRectChanged};\r\n    }\r\n\r\n    /**\r\n     * Computes intersection data.\r\n     *\r\n     * @param {Element} container - Container element.\r\n     * @param {ClientRect} [containterRect]\r\n     * @param {ClientRect} [targetRect]\r\n     * @returns {Object}\r\n     */\r\n    getIntersectionData(container, containterRect, targetRect) {\r\n        const target = this.target;\r\n\r\n        if (!targetRect) {\r\n            targetRect = getRectangle(this.target);\r\n        }\r\n\r\n        if (!containterRect) {\r\n            containterRect = getRectangle(container);\r\n        }\r\n\r\n        let detached        = isDetached(container, target),\r\n            intersecRect    = !detached ? getIntersection(container, target, containterRect, targetRect) : emptyRect,\r\n            intersects      = !detached && intersecRect.width >= 0 && intersecRect.height >= 0,\r\n            intersecRatio   = getArea(intersecRect) / getArea(targetRect) || 0;\r\n\r\n        return {\r\n            rect: intersecRect,\r\n            ratio: intersecRatio,\r\n            exists: intersects\r\n        };\r\n    }\r\n}\r\n","import {WeakMap} from './shims/es6-collections';\r\nimport IntersectionObserverController from './IntersectionObserverController';\r\nimport _IntersectionObserver from './_IntersectionObserver';\r\n\r\n// This controllers' instance will be assigned to all IntersectionObservers\r\nconst controller = new IntersectionObserverController();\r\n\r\n// Registry of internal observers.\r\nconst observers = new WeakMap();\r\n\r\n/**\r\n * IntersectionObservers' \"Proxy\" class which is meant to hide private\r\n * properties and methods from IntersectionObserver instances.\r\n *\r\n * Additionally it implements \"idleTimeout\" and \"trackHovers\" static property\r\n * accessors to give a control over the behavior of IntersectionObserverController\r\n * instance. Changes made to these properties will affect both future and\r\n * existing instances of IntersectionObserver.\r\n */\r\nclass IntersectionObserver {\r\n    /**\r\n     * Creates instance of public IntersectionObserver.\r\n     *\r\n     * @param {Function} callback\r\n     * @param {Object} options\r\n     */\r\n    constructor(callback, options) {\r\n        if (!arguments.length) {\r\n            throw new TypeError(\"1 argument required, but only 0 present.\");\r\n        }\r\n\r\n        const observer = new _IntersectionObserver(callback, options, controller, this);\r\n\r\n        // Due to the spec following properties are non-writable\r\n        // and in native implementation they are also not enumerable.\r\n        Object.defineProperties(this, {\r\n            root:       {value: observer.root},\r\n            thresholds: {value: observer.thresholds},\r\n            rootMargin: {value: observer.rootMargin}\r\n        });\r\n\r\n        // Register internal observer.\r\n        observers.set(this, observer);\r\n    }\r\n\r\n    /**\r\n     * Extracts controllers' idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    static get idleTimeout() {\r\n        return controller.idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    static set idleTimeout(value) {\r\n        if (typeof value !== 'number') {\r\n            throw new TypeError('type of \"idleTimeout\" value must be a number.');\r\n        }\r\n\r\n        if (typeof value < 0) {\r\n            throw new TypeError('\"idleTimeout\" value must be greater than 0.');\r\n        }\r\n\r\n        controller.idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Tells whether controller tracks \"hover\" events.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    static get trackHovers() {\r\n        return controller.isHoverEnabled();\r\n    }\r\n\r\n    /**\r\n     * Enables or disables tracking of \"hover\" event.\r\n     *\r\n     * @param {Boolean} value - Whether to disable or enable tracking.\r\n     */\r\n    static set trackHovers(value) {\r\n        if (typeof value !== 'boolean') {\r\n            throw new TypeError('type of \"trackHovers\" value must be a boolean.');\r\n        }\r\n\r\n        value ?\r\n            controller.enableHover() :\r\n            controller.disableHover();\r\n    }\r\n}\r\n\r\n// Expose public methods of IntersectionObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect',\r\n    'takeRecords'\r\n].forEach(method => {\r\n    IntersectionObserver.prototype[method] = function () {\r\n        return observers.get(this)[method](...arguments);\r\n    };\r\n});\r\n\r\nexport default IntersectionObserver;\r\n","import now from './shims/performance.now';\r\n\r\nconst mutationsSupported = typeof window.MutationObserver === 'function';\r\n\r\n/**\r\n * A shim for requestAnimationFrame which falls back\r\n * to setTimeout if the first one is not supported.\r\n *\r\n * @returns {Number} Request identifier.\r\n */\r\nconst requestAnimFrame = (function () {\r\n    if (window.requestAnimationFrame) {\r\n        return window.requestAnimationFrame;\r\n    }\r\n\r\n    return callback => {\r\n        return setTimeout(() => callback(now()), 1000 / 60);\r\n    };\r\n})();\r\n\r\n/**\r\n * Creates a wrapper function that ensures that\r\n * provided callback will be invoked only after\r\n * the specified delay.\r\n *\r\n * @param {Function} callback\r\n * @param {Number} [delay = 0]\r\n * @returns {Function}\r\n */\r\nfunction debounce(callback, delay = 0) {\r\n    let timeoutID = false;\r\n\r\n    return function (...args) {\r\n        if (timeoutID !== false) {\r\n            clearTimeout(timeoutID);\r\n        }\r\n\r\n        timeoutID = setTimeout(() => {\r\n            timeoutID = false;\r\n\r\n            callback.apply(this, args);\r\n        }, delay);\r\n    };\r\n}\r\n\r\n/**\r\n * Controller class that is used to handle updates of registered IntersectionObservers.\r\n * It controls when and for how long it's necessary to run updates of observations\r\n * by listening to various events on window along with DOM mutations\r\n * (nodes removal, changes of attributes, etc.).\r\n  *\r\n * CSS transitions and animations are handled by running the update cycle\r\n * until position of DOM elements, added to connected observers, keeps changing\r\n * or until the idle timeout is reached (default timeout is 50 milliseconds).\r\n * Timeout value can be manually increased if transitions have a delay.\r\n *\r\n * Tracking of changes made by \":hover\" class is optional and can be\r\n * enabled by invoking the \"enableHover\" method.\r\n *\r\n * Infinite update cycle along with a listener of \"click\" event will be used in case when\r\n * MutatioObserver is not supported.\r\n */\r\nexport default class IntersectionObserverController {\r\n    /**\r\n     * Creates new IntersectionObserverController instance.\r\n     *\r\n     * @param {Number} [idleTimeout = 50]\r\n     * @pram {Boolean} [trackHovers = false] - Whether to track \"mouseover\"\r\n     *      events or not. Disabled be default.\r\n     */\r\n    constructor(idleTimeout = 50, trackHovers = false) {\r\n        this._idleTimeout = idleTimeout;\r\n        this._trackHovers = trackHovers;\r\n        this._cycleStartTime = -1;\r\n\r\n        // Indicates whether the update of observers is scheduled.\r\n        this._isUpdateScheduled = false;\r\n\r\n        // Indicates whether infinite cycles are enabled.\r\n        this._repeatCycle = false;\r\n\r\n        // Indicates whether \"mouseover\" event handler was added.\r\n        this._hoverInitiated = false;\r\n\r\n        // Keeps reference to the instance of MutationObserver.\r\n        this._mutationsObserver = null;\r\n\r\n        // Indicates whether DOM listeners were initiated.\r\n        this._isListening = false;\r\n\r\n        // A list of connected observers.\r\n        this._observers = [];\r\n\r\n        // Fix value of \"this\" binding for the following methods.\r\n        this.startUpdateCycle = this.startUpdateCycle.bind(this);\r\n        this.scheduleUpdate = this.scheduleUpdate.bind(this);\r\n        this._onMutation = this._onMutation.bind(this);\r\n\r\n        // Function that will be invoked to re-rerun the update cycle\r\n        // if repeatable cycles are enabled.\r\n        this._repeatHandler = debounce(this.scheduleUpdate, 200);\r\n\r\n        // \"mouseover\" event handler.\r\n        this._onMouseOver = debounce(this.startUpdateCycle, 200);\r\n    }\r\n\r\n    /**\r\n     * Returns current idle timeout value.\r\n     *\r\n     * @returns {Number}\r\n     */\r\n    get idleTimeout() {\r\n        return this._idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Sets up new idle timeout value.\r\n     *\r\n     * @param {Number} value - New timeout value.\r\n     */\r\n    set idleTimeout(value) {\r\n        this._idleTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {IntersectionObserver} observer - Observer to be added.\r\n     */\r\n    connect(observer) {\r\n        if (!this.isConnected(observer)) {\r\n            this._observers.push(observer);\r\n        }\r\n\r\n        // Instantiate listeners if they\r\n        // weren't instantiated yet.\r\n        if (!this._isListening) {\r\n            this._initListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {IntersectionObserver} observer - Observer to be removed.\r\n     */\r\n    disconnect(observer) {\r\n        let observers = this._observers,\r\n            index = observers.indexOf(observer);\r\n\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n\r\n        // Remove listeners if controller\r\n        // has no connected observers.\r\n        if (!observers.length && this._isListening) {\r\n            this._removeListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether provided observer is connected to controller.\r\n     *\r\n     * @param {IntersectionObserver} observer - Observer to be checked.\r\n     * @returns {Boolean}\r\n     */\r\n    isConnected(observer) {\r\n        return !!~this._observers.indexOf(observer);\r\n    }\r\n\r\n    /**\r\n     * Updates every observer from observers list and\r\n     * notifies them of queued entries.\r\n     *\r\n     * @private\r\n     * @returns {Boolean} Returns \"true\" if any observer\r\n     *      has detected changes in position of its elements.\r\n     */\r\n    _updateObservers() {\r\n        let hasChanges = false;\r\n\r\n        for (const observer of this._observers) {\r\n            if (observer.updateObservations()) {\r\n                hasChanges = true;\r\n            }\r\n\r\n            if (observer.hasEntries()) {\r\n                observer.notifySubscriber();\r\n            }\r\n        }\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Schedules new update cycle.\r\n     */\r\n    startUpdateCycle() {\r\n        this._cycleStartTime = now();\r\n\r\n        this.scheduleUpdate();\r\n    }\r\n\r\n    /**\r\n     * Controls invocation of \"_updateObservers\" method.\r\n     * It will re-invoke itself in the following cases:\r\n     *      - Update of observers detected changes in elements position.\r\n     *        In this case we need to postpone cycle end time in order to ensure\r\n     *        that we won't miss next iteration of animations.\r\n     *\r\n     *      - Idle timeout wasn't reached yet.\r\n     *        In this case we need to schedule new single update\r\n     *        because changes may be delayed.\r\n     *\r\n     * @param {Number} [timestamp] - Internal parameter\r\n     *      that is used to define whether method was invoked\r\n     *      as a callback of requestAnimationFrame.\r\n     */\r\n    scheduleUpdate(timestamp) {\r\n        let calledFromRAF = typeof timestamp === 'number';\r\n\r\n        // Invoke the update of observers only if function\r\n        // was called as a requestAnimationFrame callback.\r\n        if (calledFromRAF) {\r\n            const hasChanges = this._updateObservers();\r\n\r\n            this._isUpdateScheduled = false;\r\n\r\n            // Do nothing if cycle wasn't started.\r\n            if (!this._wasCycleStarted()) {\r\n                return;\r\n            }\r\n\r\n            if (hasChanges) {\r\n                // Postpone cycle end time if changes were detected.\r\n                this.startUpdateCycle();\r\n            } else if (!this._hasIdleTimeEnded()) {\r\n                // Schedule new single update if cycle timeout wasn't reached yet.\r\n                this.scheduleUpdate();\r\n            } else {\r\n                // Finish cycle.\r\n                this._onCycleEnded();\r\n            }\r\n        } else if (!this._isUpdateScheduled) {\r\n            // Request new update if it wasn't requested already.\r\n            requestAnimFrame(this.scheduleUpdate);\r\n\r\n            this._isUpdateScheduled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tells whether cycle has reached its idle timeout.\r\n     *\r\n     * @private\r\n     * @returns {Boolean}\r\n     */\r\n    _hasIdleTimeEnded() {\r\n        return now() - this._cycleStartTime > this._idleTimeout;\r\n    }\r\n\r\n    /**\r\n     * Tells whether the update cycle is currently running.\r\n     *\r\n     * @private\r\n     * @returns {Boolean}\r\n     */\r\n    _wasCycleStarted() {\r\n        return this._cycleStartTime !== -1;\r\n    }\r\n\r\n    /**\r\n     * Callback that will be invoked after the update cycle is finished.\r\n     *\r\n     * @private\r\n     */\r\n    _onCycleEnded() {\r\n        // Mark that update cycle is not running.\r\n        this._cycleStartTime = -1;\r\n\r\n        if (this._repeatCycle) {\r\n            // Time is set to '0' because we want to automatically\r\n            // start update cycle when single update detects changes.\r\n            this._cycleStartTime = 0;\r\n\r\n            this._repeatHandler();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _initListeners() {\r\n        // Do nothing if listeners are already initiated.\r\n        if (this._isListening) {\r\n            return;\r\n        }\r\n\r\n        this._isListening = true;\r\n\r\n        // Use update cycle here instead of a single update because we may encounter\r\n        // with delayed changes, e.g. when width or height of an\r\n        // element are changed by CSS transitions.\r\n        window.addEventListener('resize', this.startUpdateCycle, true);\r\n\r\n        window.addEventListener('scroll', this.scheduleUpdate, true);\r\n\r\n        // Listen to possible changes made by \":hover\" class.\r\n        if (this._trackHovers) {\r\n            this._addHoverListener();\r\n        }\r\n\r\n        // Fall back to repeatable cycle with additional tracking of\r\n        // \"click\" event if MutationObserver is not supported.\r\n        if (!mutationsSupported) {\r\n            this._repeatCycle = true;\r\n\r\n            // Listen to clicks as they may cause changes in elements position.\r\n            window.addEventListener('click', this.startUpdateCycle, true);\r\n\r\n            // Manually start cycle.\r\n            this.startUpdateCycle();\r\n        } else {\r\n            // Subscribe to DOM mutations as they may lead to changes in position of elements.\r\n            this._mutationsObserver = new MutationObserver(this._onMutation);\r\n\r\n            this._mutationsObserver.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all DOM listeners.\r\n     *\r\n     * @private\r\n     */\r\n    _removeListeners() {\r\n        // Do nothing if listeners were already removed.\r\n        if (!this._isListening) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener('resize', this.startUpdateCycle, true);\r\n        window.removeEventListener('scroll', this.scheduleUpdate, true);\r\n\r\n        this._removeHoverListener();\r\n\r\n        if (!mutationsSupported) {\r\n            this._repeatCycle = false;\r\n\r\n            window.removeEventListener('click', this.startUpdateCycle, true);\r\n        } else if (this._mutationsObserver) {\r\n            this._mutationsObserver.disconnect();\r\n            this._mutationsObserver = null;\r\n        }\r\n\r\n        this._isListening = false;\r\n    }\r\n\r\n    /**\r\n     * Enables hover listener.\r\n     */\r\n    enableHover() {\r\n        this._trackHovers = true;\r\n\r\n        // Manually add hover listener\r\n        // if listeners were already initiated.\r\n        if (this._isListening) {\r\n            this._addHoverListener();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables hover listener.\r\n     */\r\n    disableHover() {\r\n        this._trackHovers = false;\r\n\r\n        this._removeHoverListener();\r\n    }\r\n\r\n    /**\r\n     * Tells whether hover listener is enabled.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isHoverEnabled() {\r\n        return this._trackHovers;\r\n    }\r\n\r\n    /**\r\n     * Adds \"mouseover\" listener if it wasn't already added.\r\n     *\r\n     * @private\r\n     */\r\n    _addHoverListener() {\r\n        if (this._hoverInitiated) {\r\n            return;\r\n        }\r\n\r\n        window.addEventListener('mouseover', this._onMouseOver, true);\r\n\r\n        this._hoverInitiated = true;\r\n    }\r\n\r\n    /**\r\n     * Removes \"mouseover\" listener if it was added previously.\r\n     *\r\n     * @private\r\n     */\r\n    _removeHoverListener() {\r\n        if (!this._hoverInitiated) {\r\n            return;\r\n        }\r\n\r\n        window.removeEventListener('mouseover', this._onMouseOver, true);\r\n\r\n        this._hoverInitiated = false;\r\n    }\r\n\r\n    /**\r\n     * DOM mutations handler.\r\n     *\r\n     * @private\r\n     * @param {Array<MutationRecord>} entries\r\n     */\r\n    _onMutation(entries) {\r\n        const runSingleUpdate = entries.every(entry => {\r\n            return entry.type !== 'attributes';\r\n        });\r\n\r\n        // Schedule single update if attributes (class, style, etc.)\r\n        // were not changed. Otherwise run update cycle because\r\n        // animations are expected to appear only in this case.\r\n        runSingleUpdate ?\r\n            this.scheduleUpdate() :\r\n            this.startUpdateCycle();\r\n    }\r\n}\r\n","import {mapToClientRect} from './geometry';\r\n\r\nexport default class IntersectionObserverEntry {\r\n    /**\r\n     * Creates new instance of IntersectionObserverEntry.\r\n     *\r\n     * @param {Element} target\r\n     * @param {ClientRect} targetRect\r\n     * @param {ClientRect} intersecRect\r\n     * @param {Number} intersecRatio\r\n     * @param {ClientRect} rootBounds\r\n     * @param {Timestamp} time\r\n     */\r\n    constructor(target, targetRect, intersecRect, intersecRatio, rootBounds, time) {\r\n\r\n        // According to the spec following properties are not writable and\r\n        // in native implementation they are also not enumerable.\r\n        Object.defineProperties(this, {\r\n            boundingClientRect: {value: targetRect},\r\n            intersectionRatio:  {value: intersecRatio},\r\n            intersectionRect:   {value: mapToClientRect(intersecRect)},\r\n            rootBounds:         {value: mapToClientRect(rootBounds)},\r\n            target:             {value: target},\r\n            time:               {value: time}\r\n        });\r\n    }\r\n}\r\n","import {Map} from './shims/es6-collections';\r\nimport {getRectangle} from './geometry';\r\nimport IntersectionObservation from './IntersectionObservation';\r\n\r\n/**\r\n * Validates and parses threshold values.\r\n * Throws an error if one of the thresholds\r\n * is non-finite or not in range of 0 and 1.\r\n *\r\n * @param {(Array<Number>|Number)} [thresholds = 0]\r\n * @returns {Array<Number>} An array of thresholds in ascending order.\r\n */\r\nfunction parseThresholds(thresholds = 0) {\r\n    let result = thresholds;\r\n\r\n    if (!Array.isArray(thresholds)) {\r\n        result = [thresholds];\r\n    } else if (!thresholds.length) {\r\n        result = [0];\r\n    }\r\n\r\n    return result.map(threshold => {\r\n        // We use Number function instead of parseFloat\r\n        // to convert boolean values and null to theirs\r\n        // numeric representation. This is done to act\r\n        // in the same manner as a native implementation.\r\n        threshold = Number(threshold);\r\n\r\n        if (!window.isFinite(threshold)) {\r\n            throw new TypeError('The provided double value is non-finite.');\r\n        } else if (threshold < 0 || threshold > 1) {\r\n            throw new RangeError('Threshold values must be between 0 and 1.');\r\n        }\r\n\r\n        return threshold;\r\n    }).sort();\r\n}\r\n\r\n/**\r\n * Validates and converts margins value (defined in a form of\r\n * CSS 'margin' property) to a list of tokens, e.g:\r\n * 1. '0px' = [['0px'], ['0px'], ['0px'], ['0px']]\r\n * 2. '5px 11px' = [['5px'], ['11px'], ['5px'], ['11px']]\r\n *\r\n * @param {String} [margins = '0px'] - Margins value to be processed.\r\n * @returns {Array<Array>} Object that contains both: a list of\r\n *      tokens and its string representation.\r\n */\r\nfunction parseMargins(margins = '0px') {\r\n    // Use regular expression in order to properly\r\n    // handle multiple spaces in-between of tokens: '0px     2px   5px'.\r\n    //\r\n    // Casting to a string is required to keep the behavior\r\n    // closer to the native implementation which converts\r\n    // an array like [[['2px 3px']]] to '2px 3px';\r\n    margins = (margins + '').split(/\\s+/);\r\n\r\n    // Chrome validates tokens length starting from version 53.\r\n    if (margins.length > 4) {\r\n        throw new Error('Extra text found at the end of rootMargin.');\r\n    }\r\n\r\n    margins[0] = margins[0] || '0px';\r\n    margins[1] = margins[1] || margins[0];\r\n    margins[2] = margins[2] || margins[0];\r\n    margins[3] = margins[3] || margins[1];\r\n\r\n    const rawData = margins.join(' ');\r\n\r\n    const parsedData = margins.map(token => {\r\n        let [,value, unit] = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(token) || [];\r\n        const pixels = unit === 'px';\r\n\r\n        value = parseFloat(value);\r\n\r\n        if (!window.isFinite(value)) {\r\n            throw new Error('rootMargin must be specified in pixels or percent.');\r\n        }\r\n\r\n        if (!pixels) {\r\n            value /= 100;\r\n        }\r\n\r\n        return {value, pixels};\r\n    });\r\n\r\n    return {rawData, parsedData};\r\n}\r\n\r\n/**\r\n * Creates new rectangle from provided one whose\r\n * dimensions will be modified by applying margins\r\n * defined in a form of [[value: Number, pixels: Boolean], ...].\r\n *\r\n * @param {ClientRect} targetRect - Initial rectangle.\r\n * @param {Array<Array>} margins - Margins data.\r\n * @returns {ClientRect} Modified rectangle.\r\n */\r\nfunction applyMargins(targetRect, margins) {\r\n    margins = margins.map((margin, index) => {\r\n        let value = margin.value;\r\n\r\n        if (!margin.pixels) {\r\n            value *= index % 2 ? targetRect.width : targetRect.height;\r\n        }\r\n\r\n        return value;\r\n    });\r\n\r\n    const result = {\r\n        top: targetRect.top - margins[0],\r\n        right: targetRect.right + margins[1],\r\n        bottom: targetRect.bottom + margins[2],\r\n        left: targetRect.left - margins[3]\r\n    };\r\n\r\n    result.width = result.right - result.left;\r\n    result.height = result.bottom - result.top;\r\n\r\n    return result;\r\n}\r\n\r\nexport default class IntersectionObserver {\r\n    /**\r\n     * Creates new IntersectionObserver instance.\r\n     *\r\n     * @param {Function} callback - Callback function that will be invoked\r\n     *      whenever one of the observed targets reaches new ratio value defined in \"options.threshold\".\r\n     * @param {Object} [options = {}] - Optional configuration.\r\n     * @param {IntersectionObserverController} controller - Associated controller instance.\r\n     * @param {IntersectionObserver} publicObserver - This value will be used as\r\n     *      a value of \"this\" binding for the callback function.\r\n     */\r\n    constructor(callback, options = {}, controller, publicObserver) {\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError(\"The callback provided as parameter 1 is not a function.\");\r\n        }\r\n\r\n        if (typeof options !== 'object') {\r\n            throw new TypeError(\"parameter 2 is not an object.\");\r\n        }\r\n\r\n        if ('root' in options && !(options.root instanceof Element)) {\r\n            throw new TypeError(\"member root is not of type Element.\");\r\n        }\r\n\r\n\r\n        const thresholds = parseThresholds(options.threshold);\r\n        const rootMargin = parseMargins(options.rootMargin);\r\n\r\n        this.root = options.root || null;\r\n        this.rootMargin = rootMargin.rawData;\r\n\r\n        // Thresholds array needs to be immutable\r\n        // according to the native implementation.\r\n        this.thresholds = Object.freeze(thresholds);\r\n\r\n        this._root = options.root || document.documentElement;\r\n        this._callback = callback;\r\n        this._rootMargin = rootMargin.parsedData;\r\n\r\n        // Registry of observed elements and\r\n        // corresponding IntersectionObservation instances.\r\n        this._targets = new Map();\r\n\r\n        // A list of queued IntersectionObserverEntry\r\n        // items that will passed to the callback function.\r\n        this._quedEntries = [];\r\n\r\n        this._publicObserver = publicObserver || this;\r\n\r\n        this.controller = controller;\r\n    }\r\n\r\n    /**\r\n     * Adds provided target to observations list.\r\n     *\r\n     * @param {Element} target - DOM element to be observed.\r\n     */\r\n    observe(target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        let targets = this._targets;\r\n\r\n        // Do nothing if target is already observed.\r\n        if (targets.has(target)) {\r\n            return;\r\n        }\r\n\r\n        // Create new IntersectionObservation instance and assign it\r\n        // to provided target.\r\n        targets.set(target, new IntersectionObservation(target, this));\r\n\r\n        // Connect current observer to controller\r\n        // if it wasn't connected yet.\r\n        if (!this.controller.isConnected(this)) {\r\n            this.controller.connect(this);\r\n        }\r\n\r\n        // Request the update of observers.\r\n        this.controller.startUpdateCycle();\r\n    }\r\n\r\n    /**\r\n     * Removes provided target from observations list.\r\n     *\r\n     * @param {Element} target - DOM element to stop observing.\r\n     */\r\n    unobserve(target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n\r\n        if (!(target instanceof Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n\r\n        let targets = this._targets;\r\n\r\n        if (targets.has(target)) {\r\n            targets.delete(target);\r\n        }\r\n\r\n        // Disconnect observer if the list of observed targets is empty.\r\n        if (!targets.size) {\r\n            this.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all targets from observations list\r\n     * and disconnects observer from associated controller, i.e.\r\n     * no updates will be invoked for it.\r\n     */\r\n    disconnect() {\r\n        this._targets.clear();\r\n        this.controller.disconnect(this);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of queued observation entries and\r\n     * clears the queue.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n    takeRecords() {\r\n        return this._quedEntries.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Invokes callback function with a list\r\n     * of queued entries if the last one is not empty.\r\n     *\r\n     * @private\r\n     */\r\n    notifySubscriber() {\r\n        const entries = this.takeRecords();\r\n        const publicObserver = this._publicObserver;\r\n\r\n        if (entries.length) {\r\n            this._callback.call(publicObserver, entries, publicObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds entry to the queue.\r\n     *\r\n     * @param {IntersectionObserverEntry} entry\r\n     */\r\n    queueEntry(entry) {\r\n        this._quedEntries.push(entry);\r\n    }\r\n\r\n    /**\r\n     * Tells whether observer has queued entries.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    hasEntries() {\r\n        return !!this._quedEntries.length;\r\n    }\r\n\r\n    /**\r\n     * Updates intersection data of each observed target.\r\n     *\r\n     * @returns {Boolean} Returns \"true\" if intersection ratio or the rectangle of one of the\r\n     *      observed targets has changed. This information is required for\r\n     *      controller to decide whether to continue running the update cycle.\r\n     */\r\n    updateObservations() {\r\n        let root     = this._root,\r\n            rootRect = this.getRootRect(),\r\n            hasChanges = false;\r\n\r\n        this._targets.forEach(observation => {\r\n            const changes = observation.updateIntersection(root, rootRect);\r\n\r\n            if (changes.ratioChanged || changes.targetRectChanged) {\r\n                hasChanges = true;\r\n            }\r\n        });\r\n\r\n        return hasChanges;\r\n    }\r\n\r\n    /**\r\n     * Finds index of the first threshold whose value is greater than provided ratio.\r\n     * In case if there is no such value the amount of thresholds will be returned.\r\n     *\r\n     * @param {Number} ratio\r\n     * @returns {Number}\r\n     */\r\n    getThresholdGreaterThan(ratio) {\r\n        let thresholds = this.thresholds,\r\n            thresholdsLen = thresholds.length,\r\n            index = 0;\r\n\r\n        while (index < thresholdsLen && thresholds[index] <= ratio) {\r\n            ++index;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Calculates rectangle of root node with applied margins.\r\n     *\r\n     * @returns {ClientRect}\r\n     */\r\n    getRootRect() {\r\n        let rootRect = getRectangle(this._root);\r\n\r\n        return applyMargins(rootRect, this._rootMargin);\r\n    }\r\n}\r\n","/**\r\n * From provided rectangle creates a new one whose\r\n * properties are not enumerable, configurable or writable.\r\n *\r\n * @param {ClientRect} rect - Initial rectangle.\r\n * @returns {ClientRect}\r\n */\r\nexport function mapToClientRect(rect) {\r\n    const descriptors = {};\r\n\r\n    for (const key of Object.keys(rect)) {\r\n        descriptors[key] = {value: rect[key]};\r\n    }\r\n\r\n    return Object.defineProperties({}, descriptors);\r\n}\r\n\r\n/**\r\n * Creates rectangle based on provided arguments.\r\n * If called without arguments then an empty rectangle\r\n * will be created.\r\n *\r\n * @param {Number} [left = 0] - Left position of rectangle.\r\n * @param {Number} [top = 0] - Top position of rectangle.\r\n * @param {Number} [width = 0] - Rectangles' width.\r\n * @param {Number} [height = 0] - Rectangles' height.\r\n * @returns {ClientRect}\r\n */\r\nexport function createRectangle(left = 0, top = 0, width = 0, height = 0) {\r\n    return {\r\n        left, top, width, height,\r\n        bottom: top + height,\r\n        right: left + width\r\n    };\r\n}\r\n\r\n/**\r\n * Returns client rectangle of provided element.\r\n * If element represents documentElement then returns\r\n * main viewport rectangle.\r\n *\r\n * @param {Element} target\r\n * @returns {ClientRect}\r\n */\r\nexport function getRectangle(target) {\r\n    if (target === document.documentElement) {\r\n        return createRectangle(0, 0, target.clientWidth, target.clientHeight);\r\n    }\r\n\r\n    return target.getBoundingClientRect();\r\n}\r\n\r\n/**\r\n * Calculates area of rectangle.\r\n *\r\n * @param {ClientRect} rect - Rectangle whose area needs to be calculated.\r\n * @returns {Number} Rectangles' area.\r\n */\r\nexport function getArea(rect) {\r\n    return rect.width * rect.height;\r\n}\r\n\r\n/**\r\n * Tells whether rectangle is empty.\r\n *\r\n * @param {ClientRect} rect - Rectangle to be checked.\r\n * @returns {Boolean}\r\n */\r\nexport function isEmpty(rect) {\r\n    return rect.height === 0 && rect.width === 0;\r\n}\r\n\r\n/**\r\n * Compares rectangles to each other.\r\n *\r\n * @param {ClientRect} first\r\n * @param {ClientRect} second\r\n * @returns {Boolean}\r\n */\r\nexport function isEqual(first, second) {\r\n    return (\r\n        first.top === second.top &&\r\n        first.left === second.left &&\r\n        first.right === second.right &&\r\n        first.bottom === second.bottom\r\n    );\r\n}\r\n","/**\r\n * Simple shims for WeakMap and Map classes.\r\n * This implementation is not meant to be used outside of IntersectionObserver modules\r\n * because it covers only limited range of use cases.\r\n */\r\n\r\nconst hasNativeCollections =\r\n    typeof window.WeakMap === 'function' &&\r\n    typeof window.Map === 'function';\r\n\r\nconst WeakMap = (function () {\r\n    if (hasNativeCollections) {\r\n        return window.WeakMap;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {Object} key\r\n     * @returns {Number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        let result = -1;\r\n\r\n        arr.some((entry, index) => {\r\n            let matches = entry[0] === key;\r\n\r\n            if (matches) {\r\n                result = index;\r\n            }\r\n\r\n            return matches;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return class {\r\n        constructor() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         * @returns {*}\r\n         */\r\n        get(key) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            return this.__entries__[index][1];\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         * @param {*} value\r\n         */\r\n        set(key, value) {\r\n            let index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         */\r\n        delete(key) {\r\n            let entries = this.__entries__,\r\n                index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Object} key\r\n         * @returns {Boolean}\r\n         */\r\n        has(key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        }\r\n    };\r\n})();\r\n\r\nconst Map = (function () {\r\n    if (hasNativeCollections) {\r\n        return window.Map;\r\n    }\r\n\r\n    return class extends WeakMap {\r\n        /**\r\n         *\r\n         * @returns {Number}\r\n         */\r\n        get size() {\r\n            return this.__entries__.length;\r\n        }\r\n\r\n        clear() {\r\n            this.__entries__.splice(0, this.__entries__.length);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @returns {Array<Array>}\r\n         */\r\n        entries() {\r\n            return this.__entries__.slice();\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @returns {Array}\r\n         */\r\n        keys() {\r\n            return this.__entries__.map(entry => entry[0]);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @returns {Array}\r\n         */\r\n        values() {\r\n            return this.__entries__.map(entry => entry[1]);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Function} callback\r\n         * @param {Object} [ctx = null]\r\n         */\r\n        forEach(callback, ctx = null) {\r\n            for (const entry of this.__entries__) {\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        }\r\n    };\r\n})();\r\n\r\nexport {Map, WeakMap};","/**\r\n * A shim for performance.now method which falls back\r\n * to Date.now if the first one is not supported.\r\n *\r\n * @returns {Timestamp}\r\n */\r\nexport default (function () {\r\n    if (window.performance && window.performance.now) {\r\n        return () => window.performance.now();\r\n    }\r\n\r\n    return () => Date.now();\r\n})();"],"sourceRoot":""}